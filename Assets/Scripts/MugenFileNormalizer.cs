using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Text;

public class MugenFileNormalizer : EditorWindow
{
    public TextAsset airFile;
    public TextAsset[] cnsFiles;

    [MenuItem("Mugen/7. File Normalizer (Fix IDs)")]
    public static void ShowWindow() => GetWindow<MugenFileNormalizer>("Normalizer");

    void OnGUI()
    {
        EditorGUILayout.LabelField("Standardize State ID == Anim ID", EditorStyles.boldLabel);
        EditorGUILayout.HelpBox("This creates NEW files (_fixed.txt) where every State uses an Animation with the same ID.", MessageType.Info);

        airFile = (TextAsset)EditorGUILayout.ObjectField("Original AIR", airFile, typeof(TextAsset), false);
        
        ScriptableObject target = this;
        SerializedObject so = new SerializedObject(target);
        SerializedProperty cnsProp = so.FindProperty("cnsFiles");
        EditorGUILayout.PropertyField(cnsProp, true);
        so.ApplyModifiedProperties();

        if (GUILayout.Button("Normalize Files"))
        {
            if (airFile != null && cnsFiles != null) Normalize();
        }
    }

    void Normalize()
    {
        string airContent = airFile.text;
        StringBuilder airBuilder = new StringBuilder(airContent);
        
        // Dictionary to store existing actions in AIR for quick lookup
        // ID -> Full Block Text
        Dictionary<int, string> airActions = ParseAirFile(airContent);
        
        int fixCount = 0;

        foreach (var file in cnsFiles)
        {
            if (file == null) continue;

            string cnsText = file.text;
            string[] lines = cnsText.Split('\n');
            StringBuilder newCnsText = new StringBuilder();

            int currentState = -1;

            for (int i = 0; i < lines.Length; i++)
            {
                string line = lines[i];
                string clean = line.Trim().ToLower();

                // Track Current State
                if (clean.StartsWith("[statedef"))
                {
                    Match match = Regex.Match(clean, @"\d+");
                    if (match.Success) currentState = int.Parse(match.Value);
                }

                // Check for Mismatched Anim
                // We look for "anim = X" but ignore triggers/variables/explods
                // Strict check: line starts with "anim" or contains " anim ="
                if (currentState != -1 && IsAnimAssignment(clean))
                {
                    string valuePart = clean.Split('=')[1].Trim();
                    // Ignore "anim" keyword if it's a variable check like "trigger1 = anim = 200"
                    if (!clean.Contains("trigger") && int.TryParse(valuePart, out int animID))
                    {
                        if (animID != currentState)
                        {
                            // MISMATCH FOUND! (State 200 uses Anim 205)
                            
                            // 1. Check if AIR already has Action 200
                            if (!airActions.ContainsKey(currentState))
                            {
                                // 2. Check if source (205) exists to copy from
                                if (airActions.ContainsKey(animID))
                                {
                                    // 3. Copy Action 205 -> Action 200
                                    string sourceBlock = airActions[animID];
                                    // Replace header [Begin Action 205] with [Begin Action 200]
                                    string newBlock = Regex.Replace(sourceBlock, @"\[Begin Action \d+\]", $"[Begin Action {currentState}]", RegexOptions.IgnoreCase);
                                    
                                    // Append to AIR builder
                                    airBuilder.AppendLine("\n;--- Auto-Generated by Normalizer ---");
                                    airBuilder.AppendLine(newBlock);
                                    
                                    // Register so we don't duplicate it next time
                                    airActions.Add(currentState, newBlock);
                                    
                                    Debug.Log($"<color=green>FIXED:</color> Copied Anim {animID} to create Anim {currentState}");
                                }
                                else
                                {
                                    Debug.LogWarning($"State {currentState} wants Anim {animID}, but Anim {animID} not found in AIR!");
                                }
                            }

                            // 4. Update CNS Line: "anim = 205" -> "anim = 200"
                            // Only replace the number part to preserve comments
                            line = Regex.Replace(line, @"=\s*\d+", $"= {currentState}");
                            fixCount++;
                        }
                    }
                }
                newCnsText.AppendLine(line);
            }

            // Save Fixed CNS
            string path = AssetDatabase.GetAssetPath(file);
            string newPath = path.Replace(".txt", "_fixed.txt");
            File.WriteAllText(newPath, newCnsText.ToString());
            Debug.Log($"Saved: {newPath}");
        }

        // Save Fixed AIR
        string airPath = AssetDatabase.GetAssetPath(airFile);
        string newAirPath = airPath.Replace(".txt", "_fixed.txt");
        File.WriteAllText(newAirPath, airBuilder.ToString());
        Debug.Log($"Saved: {newAirPath}");

        AssetDatabase.Refresh();
        Debug.Log($"<b>Normalization Complete!</b> Fixed {fixCount} state discrepancies.");
    }

    bool IsAnimAssignment(string line)
    {
        // Basic check to differentiate "anim = 200" from "trigger1 = anim = 200"
        line = line.Trim();
        return line.StartsWith("anim") && line.Contains("=");
    }

    Dictionary<int, string> ParseAirFile(string text)
    {
        Dictionary<int, string> actions = new Dictionary<int, string>();
        string[] lines = text.Split('\n');
        int currentID = -1;
        StringBuilder currentBlock = new StringBuilder();

        foreach (string line in lines)
        {
            string clean = line.Trim();
            if (clean.StartsWith("[Begin Action", System.StringComparison.OrdinalIgnoreCase))
            {
                // Save previous
                if (currentID != -1) actions[currentID] = currentBlock.ToString();

                // Start new
                currentBlock.Clear();
                Match m = Regex.Match(clean, @"\d+");
                if (m.Success) currentID = int.Parse(m.Value);
            }
            
            if (currentID != -1) currentBlock.AppendLine(line);
        }
        // Save last
        if (currentID != -1) actions[currentID] = currentBlock.ToString();
        
        return actions;
    }
}